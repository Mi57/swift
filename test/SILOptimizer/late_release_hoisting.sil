// RUN: %target-sil-opt -enable-sil-verify-all -late-release-hoisting %s | %FileCheck %s

import Builtin
import Swift

//===----------------------------------------------------------------------===//
// Unit tests for reachability to and from local objects.
//===----------------------------------------------------------------------===//

class HasObj {
  var o : AnyObject
}

class HasInt64 {
  var i : Int64
}

class HasHasObj {
  var ho : HasObj
}

// The release of %lo can be hoisted over the load because it does not
// point to any escaping references.
//
// CHECK-LABEL: sil @testLocalNotReachesEscaped : $@convention(thin) (Int64, @owned HasObj) -> AnyObject {
// CHECK: bb0(%0 : $Int64, %1 : $HasObj):
// CHECK:   [[LO:%.*]] = alloc_ref $HasInt
// CHECK:   [[IADR:%.*]] = ref_element_addr [[LO]] : $HasInt64, #HasInt64.i
// CHECK:   store %0 to [[IADR]] : $*Int64
// CHECK:   strong_release [[LO]] : $HasInt
// CHECK:   [[OADR:%.*]] = ref_element_addr %1 : $HasObj, #HasObj.o
// CHECK:   [[O:%.*]] = load [[OADR]] : $*AnyObject
// CHECK:   return [[O]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testLocalNotReachesEscaped'
sil @testLocalNotReachesEscaped : $@convention(thin) (Int64, @owned HasObj) -> AnyObject {
bb0(%0 : $Int64, %1 : $HasObj):
  %lo = alloc_ref $HasInt64
  %iadr = ref_element_addr %lo : $HasInt64, #HasInt64.i
  store %0 to %iadr : $*Int64

  %oadr = ref_element_addr %1 : $HasObj, #HasObj.o
  %o = load %oadr : $*AnyObject
  strong_release %lo : $HasInt64
  return %o : $AnyObject
}

// The release of %lo cannot be hoisted above the load from %oadr
// because there is a points-to relation between %lo and %oadr. In
// this case, the contents of %lo point to the %0 arg, and the
// contents of the %0 arg are considered escaping because it is
// stored; forward traversal of the points-to graph fails when it sees
// an escaping node resulting in a may-alias answer for %lo and %oadr.
//
// CHECK-LABEL: sil @testLocalReachesEscaped : $@convention(thin) (@owned HasObj) -> AnyObject {
// CHECK: bb0(%0 : $HasObj):
// CHECK:   [[LO:%.*]] = alloc_ref $HasHasObj
// CHECK:   [[HOADR:%.*]] = ref_element_addr [[LO]] : $HasHasObj, #HasHasObj.ho
// CHECK:   strong_retain %0 : $HasObj
// CHECK:   store %0 to [[HOADR]] : $*HasObj
// CHECK:   [[HO:%.*]] = load [[HOADR]] : $*HasObj
// CHECK:   [[OADR:%.*]] = ref_element_addr [[HO]] : $HasObj, #HasObj.o
// CHECK:   [[O:%.*]] = load [[OADR]] : $*AnyObject
// CHECK:   strong_release [[LO]] : $HasHasObj
// CHECK:   return [[O]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testLocalReachesEscaped'
sil @testLocalReachesEscaped : $@convention(thin) (@owned HasObj) -> AnyObject {
bb0(%0 : $HasObj):
  %lo = alloc_ref $HasHasObj
  %hoadr = ref_element_addr %lo : $HasHasObj, #HasHasObj.ho
  strong_retain %0 : $HasObj
  store %0 to %hoadr : $*HasObj
  %ho = load %hoadr : $*HasObj
  %oadr = ref_element_addr %ho : $HasObj, #HasObj.o
  %o = load %oadr : $*AnyObject
  // Normally a retain of %o would precede this release of %c. But
  // let's assume some aggressive optimization happened in order to prove
  // that ARC analysis is generally safe.
  strong_release %lo : $HasHasObj
  return %o : $AnyObject
}

// EscapeAnalysis currently considers the local object %a as globally
// escaping, even though it is only stored into another local object.
// However, in theory it could consider %a to be local, and would
// still need to recognize the points-to connection between %c and %a
// This is the closest I could come to a local points-to releation
// that isn't already rooted in the same underlying object (and thus
// already considered to be a may-alias address).
//
// CHECK-LABEL: sil @testLocalReachesLocal : $@convention(thin) (AnyObject) -> AnyObject {
// CHECK: bb0(%0 : $AnyObject):
// CHECK: [[LO:%.*]] = alloc_ref $HasObj
// CHECK: [[OADR:%.*]] = ref_element_addr %1 : $HasObj, #HasObj.o
// CHECK: strong_retain %0 : $AnyObject
// CHECK: store %0 to [[OADR]] : $*AnyObject
// CHECK: [[HHO:%.*]] = alloc_ref $HasHasObj
// CHECK: [[HOADR:%.*]] = ref_element_addr [[HHO]] : $HasHasObj, #HasHasObj.ho
// CHECK: store [[LO]] to [[HOADR]] : $*HasObj
// CHECK: [[HO:%.*]] = load [[HOADR]] : $*HasObj
// CHECK: [[OADR2:%.*]] = ref_element_addr [[HO]] : $HasObj, #HasObj.o
// CHECK: [[O:%.*]] = load %9 : $*AnyObject
// CHECK: strong_release [[HHO]] : $HasHasObj
// CHECK: return [[O]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testLocalReachesLocal'
sil @testLocalReachesLocal : $@convention(thin) (AnyObject) -> AnyObject {
bb0(%0 : $AnyObject):
  %a = alloc_ref $HasObj
  %oadr = ref_element_addr %a : $HasObj, #HasObj.o
  strong_retain %0 : $AnyObject
  store %0 to %oadr : $*AnyObject

  %hho = alloc_ref $HasHasObj
  %aadr = ref_element_addr %hho : $HasHasObj, #HasHasObj.ho
  store %a to %aadr : $*HasObj

  %a2 = load %aadr : $*HasObj
  %oadr2 = ref_element_addr %a2 : $HasObj, #HasObj.o
  %o = load %oadr2 : $*AnyObject
  // Normally a retain of %o would precede this release of %hho. But
  // let's assume some aggressive optimization removed the retain in
  // order to prove that ARC alias analysis is safe in this specific case.
  strong_release %hho : $HasHasObj
  return %o : $AnyObject
}

// Hoist the release of an escaping object above memory operations on
// a local object that never escapes.
//
// CHECK-LABEL: sil @testEscapeNotReachesLocal : $@convention(thin) (Int64, @owned HasObj) -> Int64 {
// CHECK: bb0(%0 : $Int64, %1 : $HasObj):
// CHECK:   strong_release %1 : $HasObj
// CHECK:   [[LO:%.*]] = alloc_ref $HasInt64
// CHECK:   [[IADR:%.*]] = ref_element_addr [[LO]] : $HasInt64, #HasInt64.i
// CHECK:   store %0 to [[IADR]] : $*Int64
// CHECK:   [[I:%.*]] = load [[IADR]] : $*Int64
// CHECK:   return [[I]] : $Int64
// CHECK-LABEL: } // end sil function 'testEscapeNotReachesLocal'
sil @testEscapeNotReachesLocal : $@convention(thin) (Int64, @owned HasObj) -> Int64 {
bb0(%0 : $Int64, %1 : $HasObj):
  %lo = alloc_ref $HasInt64
  %iadr = ref_element_addr %lo : $HasInt64, #HasInt64.i
  store %0 to %iadr : $*Int64
  %i = load %iadr : $*Int64
  strong_release %1 : $HasObj
  return %i : $Int64
}

// EscapeAnalysis must consider the local object %lo as globally
// escaping because it is stored into an object that escapes via an
// incoming argument. This creates an aliasing relationship preventing
// the strong_release from being hoisted.
//
// CHECK-LABEL: sil @testEscapeReachesLocal : $@convention(thin) (@owned AnyObject, @owned HasHasObj) -> AnyObject {
// CHECK: bb0(%0 : $AnyObject, %1 : $HasHasObj):
// CHECK:   [[LO:%.*]] = alloc_ref $HasObj
// CHECK:   [[OADR:%.*]] = ref_element_addr [[LO]] : $HasObj, #HasObj.o
// CHECK:   store %0 to [[OADR]] : $*AnyObject
// CHECK:   [[HOADR:%.*]] = ref_element_addr %1 : $HasHasObj, #HasHasObj.ho
// CHECK:   store [[LO]] to [[HOADR]] : $*HasObj
// CHECK:   [[O:%.*]] = load [[OADR]] : $*AnyObject
// CHECK:   strong_release %1 : $HasHasObj
// CHECK:   return [[O]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testEscapeReachesLocal'
sil @testEscapeReachesLocal : $@convention(thin) (@owned AnyObject, @owned HasHasObj) -> AnyObject {
bb0(%0 : $AnyObject, %1 : $HasHasObj):
  %lo = alloc_ref $HasObj
  %oadr = ref_element_addr %lo : $HasObj, #HasObj.o
  store %0 to %oadr : $*AnyObject
  %hoadr = ref_element_addr %1 : $HasHasObj, #HasHasObj.ho
  store %lo to %hoadr : $*HasObj
  %o = load %oadr : $*AnyObject
  strong_release %1 : $HasHasObj
  return %o : $AnyObject
}
