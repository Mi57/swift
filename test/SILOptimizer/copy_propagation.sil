// RUN: %target-sil-opt -copy-propagation -enable-sil-opaque-values -enable-sil-verify-all %s | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

// CHECK-LABAL: sil @testVarAssign : $@convention(thin) <T> (@in T) -> @out T {
// CHECK: bb0(%0 : $T):
// CHECK:   [[LOCAL:%.*]] = alloc_stack $T, var, name "u"
// CHECK:   store %0 to [init] [[LOCAL]] : $*T
// CHECK:   destroy_addr [[LOCAL]] : $*T
// CHECK:   dealloc_stack [[LOCAL]] : $*T
// CHECK:   return %0 : $T
// CHECK-LABEL: } // end sil function 'testVarAssign'
sil @testVarAssign : $@convention(thin) <T> (@in T) -> @out T {
bb0(%0 : $T):
  %2 = alloc_stack $T, var, name "u"
  %3 = copy_value %0 : $T
  store %3 to [init] %2 : $*T
  destroy_addr %2 : $*T
  dealloc_stack %2 : $*T
  destroy_value %0 : $T
  return %3 : $T
}

// CHECK: sil @multiResult : $@convention(thin) <T> (@in T) -> (@out T, @out T) {
// CHECK: bb0(%0 : $T):
// CHECK:   [[COPY:%.*]] = copy_value %0 : $T
// CHECK:   [[R:%.*]] = tuple ([[COPY]] : $T, %0 : $T)
// CHECK:   return [[R]] : $(T, T)
// CHECK: } // end sil function 'multiResult'
sil @multiResult : $@convention(thin) <T> (@in T) -> (@out T, @out T) {
bb0(%0 : $T):
  debug_value %0 : $T, let, name "t", argno 1
  %2 = copy_value %0 : $T
  %3 = tuple (%2 : $T, %0 : $T)
  return %3 : $(T, T)
}

// CHECK-LABEL: sil @callMultiResult : $@convention(thin) <T> (@in T) -> @out T {
// CHECK: bb0(%0 : $T):
// CHECK:   [[F:%.*]] = function_ref @multiResult : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK:   [[CALL:%.*]] = apply [[F]]<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK:   [[E0:%.*]] = tuple_extract [[CALL]] : $(T, T), 0
// CHECK:   [[E0COPY:%.*]] = copy_value [[E0]] : $T
// CHECK:   [[E1:%.*]] = tuple_extract [[CALL]] : $(T, T), 1
// CHECK:   [[E1COPY:%.*]] = copy_value [[E1]] : $T
// CHECK:   destroy_value [[CALL]] : $(T, T)
// CHECK:   destroy_value [[E0COPY]] : $T
// CHECK:   return [[E1COPY]] : $T
// CHECK: } // end sil function 'callMultiResult'
sil @callMultiResult : $@convention(thin) <T> (@in T) -> @out T {
bb0(%0 : $T):
  %2 = copy_value %0 : $T
  %3 = function_ref @multiResult : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  %4 = apply %3<T>(%2) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  %5 = tuple_extract %4 : $(T, T), 0
  %6 = copy_value %5 : $T
  %7 = tuple_extract %4 : $(T, T), 1
  %8 = copy_value %7 : $T
  destroy_value %4 : $(T, T)
  destroy_value %6 : $T
  destroy_value %0 : $T
  return %8 : $T
}
