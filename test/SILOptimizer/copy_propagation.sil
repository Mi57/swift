// RUN: %target-sil-opt -copy-propagation -enable-sil-ownership -enable-sil-opaque-values -enable-sil-verify-all %s | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

// Once Mem2Reg supports ownership, it will leave behind extra copies as
// seen in the SIL test below for simple assignment:
// public func testVarAssign<T>(_ t: T) -> T {
//  var u = t
//  return u
// }
// CopyPropagation should leave behind a single copy and no destroys.
//
// CHECK-LABEL: sil @testVarAssign : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK-NOT: destroy
// CHECK:   [[CPY:%.*]] = copy_value %0 : $T
// CHECK-NOT: destroy
// CHECK:   return [[CPY]] : $T
// CHECK-LABEL: } // end sil function 'testVarAssign'
sil @testVarAssign : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = copy_value %1 : $T
  destroy_value %1 : $T
  return %2 : $T
}

// CHECK: sil @multiReturnValue : $@convention(thin) <T> (@in_guaranteed T) -> (@out T, @out T) {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK-NOT: destroy
// CHECK:   [[CPY1:%.*]] = copy_value %0 : $T
// CHECK-NOT: destroy
// CHECK:   [[CPY2:%.*]] = copy_value %0 : $T
// CHECK-NOT: destroy
// CHECK:   [[R:%.*]] = tuple ([[CPY1]] : $T, [[CPY2]] : $T)
// CHECK-NOT: destroy
// CHECK:   return [[R]] : $(T, T)
// CHECK: } // end sil function 'multiReturnValue'
sil @multiReturnValue : $@convention(thin) <T> (@in_guaranteed T) -> (@out T, @out T) {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = copy_value %1 : $T
  %3 = copy_value %1 : $T
  %4 = tuple (%2 : $T, %3 : $T)
  destroy_value %1 : $T
  return %4 : $(T, T)
}

// CHECK-LABEL: sil @multiCallResult : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK-NEXT: // function_ref multiReturnValue
// CHECK-NEXT: [[F:%.*]] = function_ref @multiReturnValue : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK-NEXT: [[CALL:%.*]] = apply [[F]]<T>(%0) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK-NEXT: ([[D1:%.*]], [[D2:%.*]]) = destructure_tuple [[CALL]] : $(T, T)
// CHECK-NEXT: destroy_value [[D2]] : $T
// CHECK-NEXT: return [[D1]] : $T
// CHECK-NEXT: } // end sil function 'multiCallResult'
sil @multiCallResult : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = function_ref @multiReturnValue : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  %3 = apply %2<T>(%1) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  (%4, %5) = destructure_tuple %3 : $(T, T)
  %6 = copy_value %4 : $T
  %7 = copy_value %5 : $T
  destroy_value %1 : $T
  destroy_value %4 : $T
  destroy_value %5 : $T
  destroy_value %7 : $T
  return %6 : $T
}
